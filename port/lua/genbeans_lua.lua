-- UTF-8 without BOM
local error = error
local print = print
local ipairs = ipairs
local format = string.format
local concat = table.concat
local open = io.open

local template_bean = [=[
-- UTF-8 without BOM
-- This file is generated by genbeans tool. Do NOT edit it!

local num, str, bool, vec, map = 0, 1, 2, 3, 4
return require "util".initBeans {
#[#	#(bean.name) = { __type = #(bean.type), __vars = {
#(#		[#(var.id2)] = { name = "#(var.name)", type = #(var.btype)#(var.keyval) },
#)#	}},
#]#}
]=]

local n, s, b, v, m = "num", "str", "bool", "vec", "map"
local typemap = { byte = n, char = n, short = n, int = n, long = n, float = n, double = n, integer = n,
	bool = b, boolean = b, string = s, octets = s, data = s, bytes = s, binary = s, bean = "\"#(var.name)\"",
	vector = v, list = v, deque = v, hashset = v, treeset = v, linkedhashset = v, array = v, arraydeque = v,
	arraylist = v, linkedlist = v, set = v, linkedset = v, hashmap = m, treemap = m, linkedhashmap = m, map = m, linkedmap = m, }

local function trim(s)
	return s:gsub("[%c ]+", "")
end
local function code_conv(code, prefix, t)
	return code:gsub("#%(" .. prefix .. "%.([%w_]+)%)", function(name) return t[name] end)
end

local name_used = {}
local type_bean = {}
local name_bean = {}
local bean_order = {}
function bean(bean)
	bean.name = trim(bean.name)
	if bean.name:find("[^%w_]") or typemap[bean.name] then error("ERROR: invalid bean.name: " .. bean.name) end
	if name_used[bean.name] then error("ERROR: duplicated bean.name: " .. bean.name) end
	if type_bean[bean.type] then error("ERROR: duplicated bean.type: " .. bean.type) end
	if bean.type < 1 or bean.type > 0x7fffffff then error("ERROR: invalid bean.type: " .. bean.type) end
	type_bean[bean.type] = bean
	name_bean[bean.name] = bean

	for _, var in ipairs(bean) do
		if var.id and (var.id < 1 or var.id > 62) then error("ERROR: id=" .. var.id .. " must be in [1, 62]") end
		if not var.id then var.id = 0 end
		var.id2 = format("%2d", var.id)
		var.name = trim(var.name)
		var.type = trim(var.type)
		local basetype
		basetype, var.k, var.v = var.type:match "^%s*([%w_]+)%s*<?%s*([%w_]*)%s*,?%s*([%w_]*)%s*>?%s*%(?%s*([%w%._]*)%s*%)?%s*$"
		var.btype = typemap[basetype] or '"' .. basetype .. '"'
		var.key = var.k and (typemap[var.k] or '"' .. var.k .. '"')
		var.val = var.v and (typemap[var.v] or '"' .. var.v .. '"')
		if var.key == '""' then var.key = nil end
		if var.val == '""' then var.val = nil end
		if not var.val then var.val = var.key; var.key = nil end
		var.keyval = (var.key and ", key = #(var.key)" or "") .. (var.val and ", value = #(var.val)" or "")
		if not var.type then
			error("ERROR: unknown type: " .. var.type .. " => " .. basetype)
		end
	end

	name_used[bean.name] = true
	bean_order[#bean_order + 1] = bean.name
end

dofile "../../allbeans.lua"

local function checksave(fn, d, change_count, pattern, typename)
	local f = open(fn, "rb")
	if f then
		local s = f:read "*a"
		f:close()
		if change_count > 0 then
			d = s:gsub("\n\t/%*\\.-\n\t\\%*/", d:gmatch("\n\t/%*\\.-\n\t\\%*/"), change_count):gsub(pattern, typename, 1)
		end
		if s == d then d = nil else print(" * " .. fn) end
	else
		print("+  " .. fn)
	end
	if d then
		f = open(fn, "wb")
		if not f then error("ERROR: can not create file: " .. fn) end
		f:write(d)
		f:close()
	end
end

local outpath = (arg[1] or "."):gsub("\\", "/")
if outpath:sub(-1, -1) ~= "/" then outpath = outpath .. "/" end

checksave(outpath .. "bean.lua", (template_bean:gsub("#%[#(.-)#%]#", function(body)
	local subcode = {}
	for _, name in ipairs(bean_order) do
		local bean = name_bean[name]
		subcode[#subcode + 1] = code_conv(body:gsub("#%(#(.-)#%)#", function(body)
			local subcode2 = {}
			for _, var in ipairs(bean) do
				if var.id > 0 then subcode2[#subcode2 + 1] = code_conv(code_conv(body, "var", var), "var", var) end
			end
			return concat(subcode2)
		end), "bean", bean)
	end
	return concat(subcode)
end)):gsub("\r", ""), 0)

print "done!"
