-- UTF-8 without BOM
local type = type
local string = string
local error = error
local pairs = pairs
local table = table
local concat = table.concat
local ipairs = ipairs
local print = print
local open = io.open

local jdk7 = false -- false for jdk6
namespace = "jane" -- for bean namespace
local namespace = namespace

local template_hint = "// This file is generated by genbeans tool. Do NOT edit it! @formatter:off\n"
local template_bean = template_hint .. [=[
package ]=] .. namespace .. [=[.bean;
#<#
import java.lang.reflect.Field;#>#
import #(bean.imports);
#(bean.comment)
public final class #(bean.name) extends Bean<#(bean.name)>
{
	private static final long serialVersionUID = #(bean.uid);
	public  static final int BEAN_TYPE = #(bean.type);
	public  static final #(bean.name) BEAN_STUB = new #(bean.name)();#(bean.pool_def)
#{#	public  static final #(var.type) #(var.name)#(var.value);#(var.comment)
#}##(##(var.field)#)#
#(#	private /*#(var.id2)*/ #(var.final)#(var.type) #(var.name);#(var.comment)
#)##<#
	static
	{
		try
		{
			Class<#(bean.name)> c = #(bean.name).class;
#(##(var.fieldget)#)#		}
		catch(Exception e)
		{
		}
	}

	public #(bean.name)()
	{
#(##(var.new)#)#	}

	public #(bean.name)(#(##(var.type_i) #(var.name), #)#)
	{
#(#		#(var.init);
#)#	}

#>#	@Override
	public void reset()
	{
#(#		#(var.reset);
#)#	}

	#(bean.param_warning)@Override
	public void assign(#(bean.name) b)
	{#<#
		if(b == this) return;
		if(b == null) { reset(); return; }#>#
#(#		#(var.assign);
#)#	}
#(#
	public #(var.type) get#(var.name_u)()
	{
		return #(var.name);
	}
#(var.set)#)#
	@Override
	public int type()
	{
		return #(bean.type);
	}

	@Override
	public #(bean.name) stub()
	{
		return BEAN_STUB;
	}

	@Override
	public #(bean.name) create()
	{
		return new #(bean.name)();
	}

	@Override
	public int initSize()
	{
		return #(bean.initsize);
	}

	@Override
	public int maxSize()
	{
		return #(bean.maxsize);
	}
#(bean.pool_func)
	@Override
	public OctetsStream marshal(OctetsStream s)
	{
#(#		#(var.marshal)
#)#		return s.marshal1((byte)0);
	}

	@Override
	public OctetsStream unmarshal(OctetsStream s) throws MarshalException
	{
		for(;;) { int i = s.unmarshalByte() & 0xff, t = i & 3; switch(i >> 2)
		{
			case 0: return s;
#(#			#(var.unmarshal) break;
#)#			default: s.unmarshalSkipVar(t);
		}}
	}

	@Override
	public #(bean.name) clone()
	{
		return new #(bean.name)(#(##(var.name), #)#);
	}

	@Override
	public int hashCode()
	{
		int h = #(bean.type) * 0x9e3779b1;
#(#		h = h * 31 + 1 + #(var.hashcode);
#)#		return h;
	}

	@Override
	public boolean equals(Object o)
	{
		if(o == this) return true;
		if(!(o instanceof #(bean.name))) return false;#<#
		#(bean.name) b = (#(bean.name))o;#>#
#(#		if(#(var.equals)) return false;
#)#		return true;
	}

	@Override
	public int compareTo(#(bean.name) b)
	{
		if(b == this) return 0;
		if(b == null) return 1;#<#
		int c;#>#
#(#		c = #(var.compareto); if(c != 0) return c;
#)#		return 0;
	}

	@Override
	public String toString()
	{
		StringBuilder s = new StringBuilder(16 + #(bean.initsize) * 2).append('{');#<#
#(#		#(var.tostring);
#)#		s.setLength(s.length() - 1);#>#
		return s.append('}').toString();
	}

	@Override
	public StringBuilder toJson(StringBuilder s)
	{
		if(s == null) s = new StringBuilder(1024);
		s.append('{');#<#
#(#		#(var.tojson);
#)#		s.setLength(s.length() - 1);#>#
		return s.append('}');
	}

	@Override
	public StringBuilder toLua(StringBuilder s)
	{
		if(s == null) s = new StringBuilder(1024);
		s.append('{');#<#
#(#		#(var.tolua);
#)#		s.setLength(s.length() - 1);#>#
		return s.append('}');
	}

	@Override
	public Safe safe(Wrap<?> parent)
	{
		return new Safe(this, parent);
	}

	public static final class Safe extends SContext.Safe<#(bean.name)>
	{
		private Safe(#(bean.name) bean, Wrap<?> parent)
		{
			super(bean, parent);
		}
#(##(var.getsafe)#(var.setsafe)#)#	}
}
]=]

local template_rpcbean = template_hint .. [=[
package ]=] .. namespace .. [=[.bean;

import jane.core.RpcBean;
#(bean.comment)
public final class #(bean.name) extends RpcBean<#(bean.arg), #(bean.res)>
{
	private static final long serialVersionUID = #(bean.uid);
	public  static final #(bean.name) BEAN_STUB = new #(bean.name)();
	public #(bean.name)() {}
	public #(bean.name)(#(bean.arg) a) { _arg = a; }
	@Override public int type() { return #(bean.type); }
	@Override public #(bean.name) stub() { return BEAN_STUB; }
	@Override public #(bean.name) create() { return new #(bean.name)(); }
	@Override public #(bean.arg) createArg() { return new #(bean.arg)(); }
	@Override public #(bean.res) createRes() { return new #(bean.res)(); }
}
]=]

local template_allbeans = template_hint .. [=[
package ]=] .. namespace .. [=[.bean;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import jane.core.Bean;#<#
import jane.core.BeanHandler;
import jane.core.IntMap;#>#

/** 全部beans的注册(自动生成的静态类) */
public final class AllBeans
{
	private AllBeans() {}

	/** 获取全部的bean实例 */
	public static Collection<Bean<?>> getAllBeans()
	{
		List<Bean<?>> r = new ArrayList<]=] .. (jdk7 and "" or "Bean<?>") .. [=[>(#(bean.count));
#(#		r.add(#(bean.name).BEAN_STUB);
#)#		return r;
	}
#[#
	public static IntMap<BeanHandler<?>> get#(hdl.name)Handlers()
	{
		IntMap<BeanHandler<?>> r = new IntMap<]=] .. (jdk7 and "" or "BeanHandler<?>") .. [=[>(#(hdl.count) * 4);
#(#		r.put(#(bean.type), new #(hdl.path).#(bean.name)Handler());
#)#		return r;
	}
#]#}
]=]

local template_bean_handler = [=[
package #(hdl.path);

import org.apache.mina.core.session.IoSession;
import jane.core.BeanHandler;
import jane.core.Log;
import jane.core.NetManager;
import ]=] .. namespace .. [=[.bean.#(bean.name);

public final class #(bean.name)Handler extends BeanHandler<#(bean.name)>
{
	/*\
#(#	|*| #(var.type) #(var.name)#(var.value);#(var.comment)
#)#	\*/

	@Override
	public void onProcess(final NetManager manager, final IoSession session, final #(bean.name) arg)
	{
		Log.log.debug("{}.onProcess: arg={}", getClass().getName(), arg);
	}
}
]=]

local template_rpc_handler = [=[
package #(hdl.path);

import org.apache.mina.core.session.IoSession;
import jane.core.Log;
import jane.core.NetManager;
import jane.core.RpcHandler;
import ]=] .. namespace .. [=[.bean.#(bean_arg.name);#<#
import ]=] .. namespace .. [=[.bean.#(bean_res.name);#>#

public final class #(bean.name)Handler extends RpcHandler<#(bean_arg.name), #(bean_res.name)>
{
	/*\
#(#	|*| #(var.type) #(var.name)#(var.value);#(var.comment)
#)#	\*/
	/*\
#(#	|*| #(var.type) #(var.name)#(var.value);#(var.comment)
#)#	\*/

	@Override
	public boolean onServer(NetManager manager, IoSession session, #(bean_arg.name) arg, #(bean_res.name) res)
	{
		Log.log.debug("{}: onServer: {}", getClass().getName(), arg);
		return true;
	}

	@Override
	public void onClient(NetManager manager, IoSession session, #(bean_arg.name) arg, #(bean_res.name) res)
	{
		Log.log.debug("{}: onClient: arg={},res={}", getClass().getName(), arg, res);
	}

	@Override
	public void onTimeout(NetManager manager, IoSession session, #(bean_arg.name) arg)
	{
		Log.log.debug("{}: onTimeout: {}", getClass().getName(), arg);
	}
}
]=]

local template_alltables = template_hint .. [=[
package ]=] .. namespace .. [=[.bean;

import #(tables.imports);

/** 全部的数据库表的注册和使用类(自动生成的静态类) */
public final class AllTables
{
	private AllTables() {}
	private static final DBManager _dbm = DBManager.instance();
	/**
	 * 注册全部的数据库表<p>
	 * 用于初始化和注册下面的全部静态成员(保持和AllBeans.register一致的用法), 并启动提交线程<br>
	 * 调用前要先初始化数据库管理器: DBManager.instance().startup(...)
	 */
	public static void register() { _dbm.startCommitThread(); }#<#
#>#
#(#	#(table.comment)public static final #(table.table)<#(table.key)#(table.comma)#(table.value), #(table.value).Safe> #(table.name) = _dbm.<#(table.key)#(table.comma)#(table.value), #(table.value).Safe>openTable(#(table.id), "#(table.name)", "#(table.lock)", #(table.cachesize)#(table.comma)#(table.keys), #(table.values));
#)#
	/**
	 * 以下内部类可以单独使用,避免初始化前面的表对象,主要用于获取表的键值类型
	 */
	public static final class Types
	{
		public static HashMap<String, Bean<?>> getKeyTypes()
		{
			HashMap<String, Bean<?>> r = new HashMap<]=] .. (jdk7 and "" or "String, Bean<?>") .. [=[>(#(tables.count) * 2);
#(#			r.put("#(table.name)", #(table.keyg));
#)#			return r;
		}

		public static HashMap<String, Bean<?>> getValueTypes()
		{
			HashMap<String, Bean<?>> r = new HashMap<]=] .. (jdk7 and "" or "String, Bean<?>") .. [=[>(#(tables.count) * 2);
#(#			r.put("#(table.name)", #(table.values));
#)#			return r;
		}
	}
}
]=]

local typedef = {}
local function merge(ta, tb)
	local r = {}
	for k, v in pairs(ta) do r[k] = v end
	for k, v in pairs(tb) do r[k] = v end
	return r
end
local function typename(var, t)
	local def = typedef[t]
	if not def then return t end
	if type(def) == "function" then
		local t = { id = 0, import = {} } def(t, 0) def = t
		for k in pairs(t.import) do var.import[k] = true end
	end
	if type(def) == "table" then return type(def.type) == "string" and def.type or def.type(var) end
	error("ERROR: unknown typename(" .. var .. ", " .. t .. ")")
end
local function subtypename(var, t)
	local def = typedef[t]
	if not def then return t end
	if type(def) == "function" then
		local t = { id = 0, import = {} } def(t, 0) def = t
		for k in pairs(t.import) do var.import[k] = true end
	end
	if type(def) == "table" then return type(def.type_o) == "string" and def.type_o or def.type_o(var) end
	error("ERROR: unknown subtypename(" .. var .. ", " .. t .. ")")
end
local function subtypename_new(var, t)
	if not var then return jdk7 and "" or ", " end
	return jdk7 and "" or subtypename(var, t)
end
local function subtypeid(t)
	local def = typedef[t]
	if not def then def = typedef.bean end
	if type(def) == "function" then local t = { id = 0, import = {} } def(t, 0) return t.subtypeid end
	if type(def) == "table" then return def.subtypeid end
	error("ERROR: unknown subtypeid(" .. t .. ")")
end
local function get_unmarshal_kv(var, kv, t)
	local s = (typedef[var[kv]] or typedef.bean).unmarshal_kv
	return type(s) == "string" and s or s(var, kv, t)
end
typedef.byte =
{
	import = { "jane.core.SBase" },
	name_u = function(var) return var.name:sub(1, 1):upper() .. var.name:sub(2) end,
	type = "byte", type_i = "byte", type_o = "Byte",
	subtypeid = 0,
	final = "",
	field = "\tprivate static Field FIELD_#(var.name);\n",
	fieldget = "\t\t\tFIELD_#(var.name) = c.getDeclaredField(\"#(var.name)\"); FIELD_#(var.name).setAccessible(true);\n";
	new = "",
	init = "this.#(var.name) = #(var.name)",
	reset = "#(var.name) = 0",
	assign = "this.#(var.name) = b.#(var.name)",
	set = [[

	public void set#(var.name_u)(#(var.type) #(var.name))
	{
		this.#(var.name) = #(var.name);
	}
]],
	getsafe = [[

		public #(var.type) get#(var.name_u)()
		{
			return _bean.#(var.name);
		}
]],
	setsafe = [[

		public void set#(var.name_u)(#(var.type) #(var.name))
		{
			if(initSContext()) _sCtx.addOnRollback(new SBase.S#(var.type_o)(_bean, FIELD_#(var.name), _bean.#(var.name)));
			_bean.#(var.name) = #(var.name);
		}
]],
	marshal = function(var) return string.format("if(this.#(var.name) != 0) s.marshal1((byte)0x%02x).marshal(this.#(var.name));", var.id * 4) end,
	unmarshal = "case #(var.id): this.#(var.name) = (#(var.type))s.unmarshalInt(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "(" .. typename(var, var[kv]) .. ")s.unmarshalIntKV(" .. t .. ")" end end,
	hashcode = "this.#(var.name)",
	equals = "this.#(var.name) != b.#(var.name)",
	compareto = "this.#(var.name) - b.#(var.name)",
	tostring = "s.append(this.#(var.name)).append(',')",
	tojson = "s.append(\"\\\"#(var.name)\\\":\").append(this.#(var.name)).append(',')",
	tolua = "s.append(\"#(var.name)=\").append(this.#(var.name)).append(',')",
}
typedef.char  = merge(typedef.byte, { type = "char",  type_i = "char",  type_o = "Char"  })
typedef.short = merge(typedef.byte, { type = "short", type_i = "short", type_o = "Short" })
typedef.int = merge(typedef.byte,
{
	type = "int",
	type_i = "int",
	type_o = "Integer",
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalInt(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalIntKV(" .. t .. ")" end end,
})
typedef.long = merge(typedef.byte,
{
	type = "long",
	type_i = "long",
	type_o = "Long",
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalLong(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalLongKV(" .. t .. ")" end end,
	hashcode = "(int)this.#(var.name)",
	compareto = "Long.signum(this.#(var.name) - b.#(var.name))",
})
typedef.bool = merge(typedef.byte,
{
	type = "boolean", type_i = "boolean", type_o = "Boolean",
	reset = "#(var.name) = false",
	marshal = function(var) return string.format("if(this.#(var.name)) s.marshal1((byte)0x%02x).marshal1((byte)1);", var.id * 4) end,
	unmarshal = "case #(var.id): this.#(var.name) = (s.unmarshalInt(t) != 0);",
	unmarshal_kv = function(var, kv, t) if kv then return "(s.unmarshalIntKV(" .. t .. ") != 0)" end end,
	hashcode = "(this.#(var.name) ? 0xcafebabe : 0xdeadbeef)",
	compareto = "(this.#(var.name) == b.#(var.name) ? 0 : (this.#(var.name) ? 1 : -1))",
})
typedef.float = merge(typedef.byte,
{
	type = "float", type_i = "float", type_o = "Float",
	subtypeid = 4,
	marshal = function(var) return string.format("if(this.#(var.name) != 0) s.marshal2(0x%04x).marshal(this.#(var.name));", var.id * 0x400 + 0x308) end,
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalFloat(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalFloatKV(" .. t .. ")" end end,
	hashcode = "Float.floatToRawIntBits(this.#(var.name))",
	compareto = "Float.compare(this.#(var.name), b.#(var.name))",
})
typedef.double = merge(typedef.byte,
{
	type = "double", type_i = "double", type_o = "Double",
	subtypeid = 5,
	marshal = function(var) return string.format("if(this.#(var.name) != 0) s.marshal2(0x%04x).marshal(this.#(var.name));", var.id * 0x400 + 0x309) end,
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalDouble(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalDoubleKV(" .. t .. ")" end end,
	hashcode = "(int)((Double.doubleToRawLongBits(this.#(var.name)) * 0x100000001L) >> 32)",
	compareto = "Double.compare(this.#(var.name), b.#(var.name))",
})
typedef.string = merge(typedef.byte,
{
	import = { "jane.core.Util", "jane.core.SBase" },
	type = "String", type_i = "String", type_o = "String",
	subtypeid = 1,
	new = "\t\t#(var.name) = \"\";\n",
	init = "this.#(var.name) = (#(var.name) != null ? #(var.name) : \"\")",
	reset = "#(var.name) = \"\"",
	assign = "this.#(var.name) = (b.#(var.name) != null ? b.#(var.name) : \"\")",
	set = [[

	public void set#(var.name_u)(#(var.type) #(var.name))
	{
		this.#(var.name) = (#(var.name) != null ? #(var.name) : "");
	}
]],
	setsafe = [[

		public void set#(var.name_u)(#(var.type) #(var.name))
		{
			if(initSContext()) _sCtx.addOnRollback(new SBase.S#(var.type_o)(_bean, FIELD_#(var.name), _bean.#(var.name)));
			_bean.#(var.name) = (#(var.name) != null ? #(var.name) : "");
		}
]],
	marshal = function(var) return string.format("if(!this.#(var.name).isEmpty()) s.marshal1((byte)0x%02x).marshal(this.#(var.name));", var.id * 4 + 1) end,
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalString(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalStringKV(" .. t .. ")" end end,
	hashcode = "this.#(var.name).hashCode()",
	equals = "!this.#(var.name).equals(b.#(var.name))",
	compareto = "this.#(var.name).compareTo(b.#(var.name))",
	tojson = "Util.toJStr(s.append(\"\\\"#(var.name)\\\":\"), this.#(var.name)).append(',')",
	tolua = "Util.toJStr(s.append(\"#(var.name)=\"), this.#(var.name)).append(',')",
})
typedef.octets = merge(typedef.string,
{
	import = { "jane.core.Octets", "jane.core.DynBean", "jane.core.SBase" },
	type = "Octets", type_i = "Octets", type_o = "Octets",
	new = "\t\t#(var.name) = new Octets(#(var.cap));\n",
	init = "this.#(var.name) = new Octets(#(var.cap)); if(#(var.name) != null) this.#(var.name).replace(#(var.name))",
	reset = "#(var.name).clear()",
	assign = "if(b.#(var.name) != null) this.#(var.name).replace(b.#(var.name)); else this.#(var.name).clear()",
	set = [[

	public <B extends Bean<B>> void marshal#(var.name_u)(Bean<B> b)
	{
		OctetsStream os = OctetsStream.wrap(this.#(var.name));
		os.resize(0);
		os.reserve(b.initSize());
		this.#(var.name) = os;
		b.marshal(os);
	}

	public <B extends Bean<B>> Bean<B> unmarshal#(var.name_u)(Bean<B> b) throws MarshalException
	{
		b.unmarshal(OctetsStream.wrap(this.#(var.name)));
		return b;
	}

	public DynBean unmarshal#(var.name_u)() throws MarshalException
	{
		DynBean b = new DynBean();
		b.unmarshal(OctetsStream.wrap(this.#(var.name)));
		return b;
	}
]],
	getsafe = [[

		public #(var.type) get#(var.name_u)()
		{
			if(initSContext()) _sCtx.addOnRollback(new SBase.SOctets(_bean, FIELD_#(var.name), _bean.#(var.name), true));
			return _bean.#(var.name);
		}

		public byte[] copyOf#(var.name_u)()
		{
			return _bean.#(var.name).getBytes();
		}

		public <B extends Bean<B>> void marshal#(var.name_u)(Bean<B> b)
		{
			if(initSContext()) _sCtx.addOnRollback(new SBase.SOctets(_bean, FIELD_#(var.name), _bean.#(var.name), false));
			_bean.#(var.name) = b.marshal(new OctetsStream(b.initSize()));
		}

		public <B extends Bean<B>> Bean<B> unmarshal#(var.name_u)(Bean<B> b) throws MarshalException
		{
			return _bean.unmarshal#(var.name_u)(b);
		}

		public DynBean unmarshal#(var.name_u)() throws MarshalException
		{
			return _bean.unmarshal#(var.name_u)();
		}

		public #(var.type) unsafe#(var.name_u)()
		{
			return _bean.#(var.name);
		}
]],
	setsafe = "",
	marshal = function(var) return string.format("if(!this.#(var.name).empty()) s.marshal1((byte)0x%02x).marshal(this.#(var.name));", var.id * 4 + 1) end,
	unmarshal = "case #(var.id): s.unmarshal(this.#(var.name), t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalOctetsKV(" .. t .. ")" end end,
	tojson = "this.#(var.name).dumpJStr(s.append(\"\\\"#(var.name)\\\":\")).append(',')",
	tolua = "this.#(var.name).dumpJStr(s.append(\"#(var.name)=\")).append(',')",
})
typedef.vector = merge(typedef.octets,
{
	import = { "java.util.ArrayList", "java.util.Collection", "jane.core.Util", "jane.core.SList" },
	type = function(var) return "ArrayList<" .. subtypename(var, var.k) .. ">" end,
	type_i = function(var) return "Collection<" .. subtypename(var, var.k) .. ">" end,
	stype = function(var) return "SList<" .. subtypename(var, var.k) .. ">" end,
	final = "final ",
	field = "",
	fieldget = "",
	new = function(var) return "\t\t#(var.name) = new ArrayList<" .. subtypename_new(var, var.k) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new ArrayList<" .. subtypename_new(var, var.k) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
	assign = "this.#(var.name).clear(); if(b.#(var.name) != null) this.#(var.name).addAll(b.#(var.name))",
	set = "",
	getsafe = [[

		public #(var.stype) get#(var.name_u)()
		{
			return new #(var.stype)(_owner, _bean.#(var.name));
		}

		public #(var.type) unsafe#(var.name_u)()
		{
			return _bean.#(var.name);
		}
]],
	marshal = function(var) return string.format([[if(!this.#(var.name).isEmpty())
		{
			s.marshal2(0x%04x).marshalUInt(this.#(var.name).size());
			for(%s v : this.#(var.name))
				s.marshal(v);
		}]], var.id * 0x400 + 0x300 + subtypeid(var.k), subtypename(var, var.k)) end,
	unmarshal = function(var) return string.format([[case #(var.id):
			{
				this.#(var.name).clear();
				if(t != 3) { s.unmarshalSkipVar(t); break; }
				t = s.unmarshalByte();
				if((t >> 3) != 0) { s.unmarshalSkipVarSub(t); break; }
				t &= 7;
				int n = s.unmarshalUInt();
				this.#(var.name).ensureCapacity(n < 0x10000 ? n : 0x10000);
				for(; n > 0; --n)
					this.#(var.name).add(%s);
			}]], get_unmarshal_kv(var, "k", "t")) end,
	compareto = "Util.compareTo(this.#(var.name), b.#(var.name))",
	tostring = "Util.append(s, this.#(var.name))",
	tojson = "Util.appendJson(s.append(\"\\\"#(var.name)\\\":\"), this.#(var.name))",
	tolua = "Util.appendLua(s.append(\"#(var.name)=\"), this.#(var.name))",
})
typedef.list = merge(typedef.vector,
{
	import = { "java.util.LinkedList", "java.util.Collection", "jane.core.Util", "jane.core.SList" },
	type = function(var) return "LinkedList<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new LinkedList<" .. subtypename_new(var, var.k) .. ">();\n" end,
	init = function(var) return "this.#(var.name) = new LinkedList<" .. subtypename_new(var, var.k) .. ">(); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
	unmarshal = function(var) return string.format([[case #(var.id):
			{
				this.#(var.name).clear();
				if(t != 3) { s.unmarshalSkipVar(t); break; }
				t = s.unmarshalByte();
				if((t >> 3) != 0) { s.unmarshalSkipVarSub(t); break; }
				t &= 7;
				for(int n = s.unmarshalUInt(); n > 0; --n)
					this.#(var.name).add(%s);
			}]], get_unmarshal_kv(var, "k", "t")) end,
})
typedef.deque = merge(typedef.list,
{
	import = { "java.util.ArrayDeque", "java.util.Collection", "jane.core.Util", "jane.core.SDeque" },
	type = function(var) return "ArrayDeque<" .. subtypename(var, var.k) .. ">" end,
	stype = function(var) return "SDeque<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new ArrayDeque<" .. subtypename_new(var, var.k) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new ArrayDeque<" .. subtypename_new(var, var.k) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
})
typedef.hashset = merge(typedef.list,
{
	import = { "java.util.HashSet", "java.util.Collection", "jane.core.Util", "jane.core.SSet" },
	type = function(var) return "HashSet<" .. subtypename(var, var.k) .. ">" end,
	stype = function(var) return "SSet<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new HashSet<" .. subtypename_new(var, var.k) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new HashSet<" .. subtypename_new(var, var.k) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
})
typedef.treeset = merge(typedef.hashset,
{
	import = { "java.util.TreeSet", "java.util.Collection", "jane.core.Util", "jane.core.SSSet" },
	type = function(var) return "TreeSet<" .. subtypename(var, var.k) .. ">" end,
	stype = function(var) return "SSSet<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new TreeSet<" .. subtypename_new(var, var.k) .. ">();\n" end,
	init = function(var) return "this.#(var.name) = new TreeSet<" .. subtypename_new(var, var.k) .. ">(); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
})
typedef.linkedhashset = merge(typedef.hashset,
{
	import = { "java.util.LinkedHashSet", "java.util.Collection", "jane.core.Util", "jane.core.SSet" },
	type = function(var) return "LinkedHashSet<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new LinkedHashSet<" .. subtypename_new(var, var.k) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new LinkedHashSet<" .. subtypename_new(var, var.k) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
})
typedef.hashmap = merge(typedef.list,
{
	import = { "java.util.HashMap", "java.util.Map.Entry", "java.util.Map", "jane.core.Util", "jane.core.SMap" },
	type = function(var) return "HashMap<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	type_i = function(var) return "Map<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	stype = function(var) return "SMap<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new HashMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new HashMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).putAll(#(var.name))" end,
	marshal = function(var) return string.format([[if(!this.#(var.name).isEmpty())
		{
			s.marshal2(0x%04x).marshalUInt(this.#(var.name).size());
			for(Entry<%s, %s> e : this.#(var.name).entrySet())
				s.marshal(e.getKey()).marshal(e.getValue());
		}]], var.id * 0x400 + 0x340 + subtypeid(var.k) * 8 + subtypeid(var.v), subtypename(var, var.k), subtypename(var, var.v)) end,
	unmarshal = function(var) return string.format([[case #(var.id):
			{
				this.#(var.name).clear();
				if(t != 3) { s.unmarshalSkipVar(t); break; }
				t = s.unmarshalByte();
				if((t >> 6) != 1) { s.unmarshalSkipVarSub(t); break; }
				int k = (t >> 3) & 7; t &= 7;
				for(int n = s.unmarshalUInt(); n > 0; --n)
					this.#(var.name).put(%s, %s);
			}]], get_unmarshal_kv(var, "k", "k"), get_unmarshal_kv(var, "v", "t")) end,
	assign = "this.#(var.name).clear(); if(b.#(var.name) != null) this.#(var.name).putAll(b.#(var.name))",
})
typedef.treemap = merge(typedef.hashmap,
{
	import = { "java.util.TreeMap", "java.util.Map", "jane.core.Util", "jane.core.SSMap" },
	type = function(var) return "TreeMap<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	stype = function(var) return "SSMap<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new TreeMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">();\n" end,
	init = function(var) return "this.#(var.name) = new TreeMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(); if(#(var.name) != null) this.#(var.name).putAll(#(var.name))" end,
	assign = "this.#(var.name).clear(); if(b.#(var.name) != null) this.#(var.name).putAll(b.#(var.name))",
})
typedef.linkedhashmap = merge(typedef.hashmap,
{
	import = { "java.util.LinkedHashMap", "java.util.Map", "jane.core.Util", "jane.core.SMap" },
	type = function(var) return "LinkedHashMap<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new LinkedHashMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new LinkedHashMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).putAll(#(var.name))" end,
	assign = "this.#(var.name).clear(); if(b.#(var.name) != null) this.#(var.name).putAll(b.#(var.name))",
})
typedef.bean = merge(typedef.octets,
{
	import = {},
	type = function(var) return var.type end,
	type_i = function(var) return var.type end,
	type_o = function(var) return var.type end,
	subtypeid = 2,
	final = "final ",
	field = "",
	fieldget = "",
	new = function(var) return "\t\t#(var.name) = new " .. var.type .. "();\n" end,
	init = function(var) return "this.#(var.name) = (#(var.name) != null ? #(var.name).clone() : new " .. var.type .. "())" end,
	reset = "#(var.name).reset()",
	assign = "this.#(var.name).assign(b.#(var.name))",
	set = "",
	getsafe = [[

		public #(var.type).Safe get#(var.name_u)()
		{
			return _bean.#(var.name).safe(this);
		}

		public #(var.type) unsafe#(var.name_u)()
		{
			return _bean.#(var.name);
		}
]],
	setsafe = "",
	marshal = function(var) return string.format([[{
			int n = s.size();
			this.#(var.name).marshal(s.marshal1((byte)0x%02x));
			if(s.size() - n < 3) s.resize(n);
		}]], var.id * 4 + 2) end,
	unmarshal = "case #(var.id): s.unmarshalBean(this.#(var.name), t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalBeanKV(new " .. typename(var, var[kv]) .. "(), " .. t .. ")" end end,
	compareto = "this.#(var.name).compareTo(b.#(var.name))",
	tojson = "this.#(var.name).toJson(s.append(\"\\\"#(var.name)\\\":\")).append(',')",
	tolua = "this.#(var.name).toLua(s.append(\"#(var.name)=\")).append(',')",
})
typedef.boolean = typedef.bool
typedef.integer = typedef.int
typedef.binary = typedef.octets
typedef.bytes = typedef.octets
typedef.data = typedef.octets
typedef.array = typedef.vector
typedef.arraydeque = typedef.deque
typedef.arraylist = typedef.vector
typedef.linkedlist = typedef.list
typedef.set = typedef.hashset
typedef.linkedset = typedef.linkedhashset
typedef.map = typedef.hashmap
typedef.linkedmap = typedef.linkedhashmap

local function trim(s)
	return s:gsub("[%c ]+", "")
end
local function do_var(var)
	if var.id and (var.id < 1 or var.id > 62) then error("ERROR: id=" .. var.id .. " must be in [1, 62]") end
	if not var.id then var.id = 0 end
	var.import = {}
	var.id2 = string.format("%2d", var.id)
	var.name = trim(var.name)
	var.type = trim(var.type)
	if var.comment and #var.comment > 0 then var.comment = " // " .. var.comment:gsub("%c", " ") else var.comment = ""  end
	if type(var.value) == "string" then var.value = "\"" .. var.value .. "\"" end
	var.value = var.value and " = " .. var.value or ""
	local basetype
	basetype, var.k, var.v, var.cap = var.type:match "^%s*([%w_]+)%s*<?%s*([%w_]*)%s*,?%s*([%w_]*)%s*>?%s*%(?%s*([%w%._]*)%s*%)?%s*$"
	if not var.cap then var.cap = "" end
	local def = typedef[basetype]
	if not def and basetype == var.type then def = typedef.bean end
	if type(def) == "table" then
		for k, v in pairs(def) do
			if type(v) == "function" then v = v(var) end
			var[k] = v
		end
	else
		error("ERROR: unknown type: " .. var.type .. " => " .. basetype)
	end
end
local function code_conv(code, prefix, t)
	return code:gsub("#%(" .. prefix .. "%.([%w_]+)%)", function(name) return t[name] end)
end
local function gen_uid(s)
	local h = 0
	for i = 1, #s do
		h = h % 0x10000000000 * 4093 + 1 + s:byte(i)
	end
	return string.format("0xbeac%04x%08xL", math.floor(h / 0x100000000) % 0x10000, h % 0x100000000)
end

local name_code = {}
local type_bean = {}
local name_bean = {}
local handlers = {}
local hdl_types = {}
local bean_order = {}
local tables = { imports = { ["java.util.HashMap"] = true, ["jane.core.Bean"] = true } }
function handler(hdls)
	handlers = hdls
	for _, v in ipairs(hdls) do
		handlers[v.name] = v
	end
end
local function bean_common(bean)
	bean.name = trim(bean.name)
	if bean.name:find("[^%w_]") or typedef[bean.name] or bean.name == "AllBeans" or bean.name == "AllTables" then error("ERROR: invalid bean.name: " .. bean.name) end
	if name_code[bean.name] then error("ERROR: duplicated bean.name: " .. bean.name) end
	if type_bean[bean.type] then error("ERROR: duplicated bean.type: " .. bean.type) end
	if bean.type < 1 or bean.type > 0x7fffffff then error("ERROR: invalid bean.type: " .. bean.type) end
	for name in (bean.handlers or ""):gmatch("([%w_]+)") do
		if not handlers[name] then error("ERROR: not defined handle: " .. name) end
		hdl_types[name] = hdl_types[name] or {}
		hdl_types[name][#hdl_types[name] + 1] = bean.type
	end
	type_bean[bean.type] = bean
	name_bean[bean.name] = bean
	bean.comment = bean.comment and #bean.comment > 0 and "\n/**\n * " .. bean.comment:gsub("\n", "<br>\n * ") .. "\n */" or ""
end
local function bean_const(code)
	return code:gsub("public  /%*", "private /*"):
		gsub("\t@Override\n\tpublic void assign%(.-\n\t}\n\n", ""):
		gsub("\tpublic void set.-\n\t}\n\n", ""):
		gsub("\n\tpublic static final class Safe.-}\n\t}\n", ""):
		gsub("import java%.lang%.reflect%.Field;\n", ""):
		gsub("import jane%.core%.DynBean;\n", ""):
		gsub("import jane%.core%.SBase;\n", ""):
		gsub("import jane%.core%.SContext;\n", ""):
		gsub("import jane%.core%.SContext%.Wrap;\n", ""):
		gsub("\tprivate static Field .-\n", ""):
		gsub("\tstatic\n.-\n\t}\n\n", ""):
		gsub("%*/ String ", "*/ final String "):
		gsub("%*/ Octets ", "*/ final Octets "):
		gsub("\tpublic <B extends Bean<B>> void marshal.-\n\t}\n\n", ""):
		gsub("\tpublic <B extends Bean<B>> Bean<B> unmarshal.-\n\t}\n\n", ""):
		gsub("\tpublic DynBean unmarshal.-\n\t}\n\n", ""):
		gsub("\n\t@Override\n\tpublic Safe safe.-\n\t}\n", ""):
		gsub("\t@Override\n\tpublic void reset%(.-\n\t}", [[
	@Override
	public void reset()
	{
		throw new UnsupportedOperationException();
	}]]):
		gsub("\t@Override\n\tpublic OctetsStream unmarshal%(.-\n\t}", [[
	@Override
	public OctetsStream unmarshal(OctetsStream s) throws MarshalException
	{
		throw new UnsupportedOperationException();
	}]])
end
local function get_imports(import)
	local imports = {}
	for k in pairs(import) do
		imports[#imports + 1] = k
	end
	table.sort(imports, function(a, b) return a:gsub("^java%.", ".") < b:gsub("^java%.", ".") end)
	return concat(imports, ";\nimport ")
end
function bean(bean)
	bean_common(bean)

	bean.import = { ["jane.core.Bean"] = true, ["jane.core.MarshalException"] = true, ["jane.core.OctetsStream"] = true, ["jane.core.SContext"] = true, ["jane.core.SContext.Wrap"] = true }
	local vartypes = { bean.name }
	for _, var in ipairs(bean) do
		do_var(var)
		if var.id > 0 then
			vartypes[#vartypes + 1] = var.type
			for _, v in ipairs(var.import) do
				bean.import[v] = true
			end
		end
	end
	if bean.poolsize and bean.poolsize > 0 then
		bean.import["jane.core.BeanPool"] = true
		bean.pool_def = "\n\tpublic  static final BeanPool<" .. bean.name .. "> BEAN_POOL = new BeanPool<" .. (jdk7 and "" or bean.name) .. ">(BEAN_STUB, " .. bean.poolsize .. ");"
		bean.pool_func = [[

	@Override
	public ]] .. bean.name .. [[ alloc()
	{
		return BEAN_POOL.alloc();
	}

	@Override
	public void free()
	{
		BEAN_POOL.free(this);
	}
]]
	else
		bean.pool_def = ""
		bean.pool_func = ""
	end

	bean.imports = get_imports(bean.import)
	bean.uid = gen_uid(concat(vartypes))

	local code = template_bean:gsub("#{#(.-)#}#", function(body)
		local subcode = {}
		for _, var in ipairs(bean) do
			if var.id == 0 then subcode[#subcode + 1] = code_conv(body, "var", var) end
		end
		return concat(subcode)
	end):gsub("#%(#(.-)#%)#", function(body)
		local subcode = {}
		for _, var in ipairs(bean) do
			if var.id > 0 then subcode[#subcode + 1] = code_conv(code_conv(body, "var", var), "var", var) end
		end
		local code = concat(subcode)
		return code:sub(-2, -1) ~= ", " and code or code:sub(1, -3)
	end)

	bean.param_warning = (#vartypes > 1 and "" or "/** @param b unused */\n\t")
	name_code[bean.name] = code_conv(code, "bean", bean):gsub(#vartypes > 1 and "#[<>]#" or "#<#(.-)#>#", ""):gsub("int h = (%d+ %* 0x9e3779b1;)\n\t\treturn h;", "return %1"):gsub("\r", "")
	bean_order[#bean_order + 1] = bean.name
	if bean.const then name_code[bean.name] = bean_const(name_code[bean.name]) end
end
function rpc(bean)
	bean_common(bean)
	bean.uid = gen_uid(name_bean[bean.arg].uid .. name_bean[bean.res].uid)
	name_code[bean.name] = code_conv(template_rpcbean, "bean", bean):gsub("\r", "")
	bean_order[#bean_order + 1] = bean.name
end
local key_conv = { int = "Integer", integer = "Integer", Integer = "Integer", long = "Long", Long = "Long", float = "Float", Float = "Float", double = "Double", Double = "Double",
					string = "String", String = "String", binary = "Octets", bytes = "Octets", data = "Octets", octets = "Octets", Octets = "Octets" }
function dbt(table)
	local key_type = key_conv[table.key]
	if key_type then
		if key_type == "Octets" then tables.imports["jane.core.Octets"] = true end
		table.table = "Table"
		table.key = key_type
		if table.memory then table.keys = "null"
		elseif key_type == "String" then table.keys = "\"\""
		elseif key_type == "Octets" then table.keys = "Octets.EMPTY"
		else table.keys = key_type .. ".BEAN_STUB" end
		table.keyg = table.keys:find("%.BEAN_STUB$") and table.keys or "null"
		table.comma = ", "
		tables.imports["jane.core.Table"] = true
	elseif table.key == "id" then
		table.table = "TableLong"
		table.key = ""
		table.keys = ""
		table.keyg = "null"
		table.comma = ""
		tables.imports["jane.core.TableLong"] = true
	else
		table.table = "Table"
		table.keys = not table.memory and "#(table.key).BEAN_STUB" or "null"
		table.keyg = table.keys
		table.comma = ", "
		tables.imports["jane.core.Table"] = true
	end
	table.values = table.memory and "null" or "#(table.value).BEAN_STUB"
	table.lock = table.lock or ""
	if table.comment and #table.comment > 0 then table.comment = "/**\n\t * " .. table.comment:gsub("\n", "<br>\n\t * ") .. "\n\t */\n\t" end
	tables[#tables + 1] = table
end

dofile "allbeans.lua"

local function checksave(fn, d, change_count, pattern, typename)
	local f = open(fn, "rb")
	if f then
		local s = f:read "*a"
		f:close()
		if change_count > 0 then
			d = s:gsub("\n\t/%*\\.-\n\t\\%*/", d:gmatch("\n\t/%*\\.-\n\t\\%*/"), change_count):gsub(pattern, typename, 1)
		end
		if s == d then d = nil else print(" * " .. fn) end
	else
		print("+  " .. fn)
	end
	if d then
		f = open(fn, "wb")
		if not f then error("ERROR: can not create file: " .. fn) end
		f:write(d)
		f:close()
	end
end

local outpath = (arg[1] or "src"):gsub("\\", "/")
if outpath:sub(-1, -1) ~= "/" then outpath = outpath .. "/" end
for name, code in pairs(name_code) do
	checksave(outpath .. namespace .. "/bean/" .. name .. ".java", code, 0)
end

checksave(outpath .. namespace .. "/bean/AllBeans.java", (template_allbeans:gsub("#%[#(.-)#%]#", function(body)
	local subcode = {}
	for _, hdl in ipairs(handlers) do
		if hdl.path then
			local types = hdl_types[hdl.name] or {}
			hdl.count = #types
			subcode[#subcode + 1] = code_conv(body:gsub("#%(#(.-)#%)#", function(body)
				local subcode2 = {}
				for _, type in ipairs(types) do
					local bean = type_bean[type]
					subcode2[#subcode2 + 1] = code_conv(body, "bean", bean)
					if not bean.arg then
						checksave(outpath .. hdl.path:gsub("%.", "/") .. "/" .. bean.name .. "Handler.java", code_conv(code_conv(template_bean_handler:gsub("#%(#(.-)#%)#", function(body)
							local subcode3 = {}
							for _, var in ipairs(bean) do
								subcode3[#subcode3 + 1] = code_conv(body, "var", var)
							end
							return concat(subcode3)
						end), "hdl", hdl), "bean", bean):gsub("\r", ""), 1, "(%s+class%s+" .. bean.name .. "Handler%s+extends%s+BeanHandler%s*<)[%w_%s]+>", "%1" .. bean.name .. ">")
					else
						local bean_sub
						local bean_arg, bean_res = name_bean[bean.arg], name_bean[bean.res]
						checksave(outpath .. hdl.path:gsub("%.", "/") .. "/" .. bean.name .. "Handler.java", code_conv(code_conv(code_conv(code_conv(template_rpc_handler:gsub("#%(#(.-)#%)#", function(body)
							bean_sub = bean_sub and bean_res or bean_arg
							local subcode3 = {}
							for _, var in ipairs(bean_sub) do
								subcode3[#subcode3 + 1] = code_conv(body, "var", var)
							end
							return concat(subcode3)
						end), "hdl", hdl), "bean", bean), "bean_arg", bean_arg), "bean_res", bean_res):gsub(bean_arg ~= bean_res and "#[<>]#" or "#%<#(.-)#%>#", ""):
							gsub("\r", ""), 2, "(%s+class%s+" .. bean.name .. "Handler%s+extends%s+RpcHandler%s*<)[%w_%s]+,[%w_%s]+>", "%1" .. bean_arg.name .. ", " .. bean_res.name .. ">")
					end
				end
				return concat(subcode2)
			end), "hdl", hdl)
		end
	end
	return concat(subcode)
end):gsub("#%(#(.-)#%)#", function(body)
	local subcode = {}
	for _, beanname in ipairs(bean_order) do
		local bean = name_bean[beanname]
		subcode[#subcode + 1] = code_conv(body, "bean", bean)
	end
	return concat(subcode)
end)):gsub(#handlers > 0 and "#[<>]#" or "#%<#(.-)#%>#", ""):gsub("#%(bean.count%)", #bean_order):gsub("\r", ""), 0)

tables.count = #tables
tables.imports["jane.core.DBManager"] = true
tables.imports = get_imports(tables.imports)
checksave(outpath .. namespace .. "/bean/AllTables.java", (code_conv(template_alltables:gsub("#%(#(.-)#%)#", function(body)
	local subcode = {}
	local names = {}
	local ids = {}
	for _, table in ipairs(tables) do
		if names[table.name] then error("ERROR: duplicated table.name: " .. table.name) end
		if ids[table.id] then error("ERROR: duplicated table.id: " .. table.id) end
		if table.id < 1 or table.id > 0x7fffffff then error("ERROR: invalid table.id: " .. table.id) end
		names[table.name] = true
		ids[table.id] = true
		subcode[#subcode + 1] = code_conv(code_conv(body, "table", table), "table", table)
	end
	return concat(subcode)
end), "tables", tables):gsub(#tables > 0 and "#[<>]#" or "#<#(.-)#>#", ""):gsub("\r", "")), 0)

print "done!"
